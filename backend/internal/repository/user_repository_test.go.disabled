package repository

import (
	"testing"

	"breakoutglobe/internal/models"
	"breakoutglobe/internal/testdata"
)

// TestUserRepository demonstrates the established test infrastructure patterns

// UserRepositoryTestScenario provides scenario-based testing for UserRepository using established patterns
type UserRepositoryTestScenario struct {
	t          *testing.T
	repository UserRepositoryInterface
	db         *testdata.TestDB
}

// newUserRepositoryTestScenario creates a new UserRepository test scenario using established patterns
func newUserRepositoryTestScenario(t *testing.T) *UserRepositoryTestScenario {
	db := testdata.Setup(t)
	repository := NewUserRepository(db.DB)
	
	return &UserRepositoryTestScenario{
		t:          t,
		repository: repository,
		db:         db,
	}
}

// cleanup cleans up test resources
func (s *UserRepositoryTestScenario) cleanup() {
	s.db.Cleanup()
}

// createUser creates a user using the repository and returns it
func (s *UserRepositoryTestScenario) createUser(user *models.User) *models.User {
	err := s.repository.Create(s.t.Context(), user)
	if err != nil {
		s.t.Errorf("Failed to create user: %v", err)
		return nil
	}
	return user
}

// expectUserCreationError expects user creation to fail with validation
func (s *UserRepositoryTestScenario) expectUserCreationError(user *models.User, expectedError string) {
	err := s.repository.Create(s.t.Context(), user)
	if err == nil {
		s.t.Errorf("Expected user creation to fail, but it succeeded")
		return
	}
	
	if expectedError != "" {
		testdata.AssertContainsError(s.t, err, expectedError)
	}
}

func TestUserRepository_Create_Success(t *testing.T) {
	// Setup using established database infrastructure
	scenario := newUserRepositoryTestScenario(t)
	defer scenario.cleanup()
	
	// Create user using fluent builder
	user := testdata.NewUser().
		WithDisplayName("Test User").
		AsGuest().
		Build()
	
	// Execute creation
	createdUser := scenario.createUser(user)
	
	// Use fluent assertions focused on business logic
	testdata.AssertUser(t, createdUser).
		HasDisplayName("Test User").
		IsGuest().
		HasRole(models.UserRoleUser).
		IsActive().
		HasCreatedAt().
		HasUpdatedAt()
	
	// Verify ID was generated
	testdata.AssertValidUUID(t, createdUser.ID)
}

func TestUserRepository_Create_ValidationError(t *testing.T) {
	scenario := newUserRepositoryTestScenario(t)
	defer scenario.cleanup()
	
	// Create user with invalid display name using fluent builder
	user := testdata.NewUser().
		WithDisplayName("AB"). // Too short (2 characters)
		AsGuest().
		Build()
	
	// Expect validation error
	scenario.expectUserCreationError(user, "display name must be at least 3 characters")
}

func TestUserRepository_GetByID_Success(t *testing.T) {
	scenario := newUserRepositoryTestScenario(t)
	defer scenario.cleanup()
	
	// Create a user first using fluent builder
	user := testdata.NewUser().
		WithDisplayName("Test User").
		AsGuest().
		Build()
	
	createdUser := scenario.createUser(user)
	
	// Now retrieve it
	retrieved, err := scenario.repository.GetByID(scenario.t.Context(), createdUser.ID)
	
	// Verify retrieval success
	testdata.AssertNoError(t, err)
	
	// Use fluent assertions to verify data integrity
	testdata.AssertUser(t, retrieved).
		HasID(createdUser.ID).
		HasDisplayName("Test User").
		IsGuest().
		HasRole(models.UserRoleUser).
		IsActive()
}

func TestUserRepository_GetByID_NotFound(t *testing.T) {
	scenario := newUserRepositoryTestScenario(t)
	defer scenario.cleanup()
	
	// Try to retrieve non-existent user
	_, err := scenario.repository.GetByID(scenario.t.Context(), "non-existent-id")
	
	// Verify error occurred
	if err == nil {
		t.Errorf("Expected error for non-existent user, but got nil")
	}
}

